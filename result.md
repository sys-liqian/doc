# 操作系统

## 进程,线程,协程的区别

- 进程是CPU资源分配的基本单位,线程是独立运行和独立调度的基本单位,CPU上真正运行的是线程)

- 进程拥有自己的资源空间,一个进程包含若干个线程,线程与CPU资源分配无关,多个线程共享同一进程内的资源
- 协程,协程是一种用户态的轻量级线程,协程拥有自己的寄存器上下文和栈.协程调度切换时,将寄存器上下文和栈保存到其他地方,在切回来的时候,恢复先前保存的寄存器上下文和栈

## 内核态,用户态

- 内核态与用户态是操作系统的两种运行级别,当程序运行在3级特权级上时,就可以称之为运行在用户态。因为这是最低特权级,是普通的用户进程运行的特权级,大部分用户直接面对的程序都是运行在用户态当程序,当进程运行在0级特权级上时,就可以称之为运行在内核态

- 运行在用户态下的程序不能直接访问操作系统内核数据结构和程序,当我们在系统中执行一个程序时,大部分时间是运行在用户态下的,在其需要操作系统帮助完成某些它没有权力和能力完成的工作时就会切换到内核态（比如操作硬件）

- 这两种状态的主要差别是
  - 处于用户态执行时,进程所能访问的内存空间和对象受到限制,其所处于占有的处理器是可被抢占的
  - 处于内核态执行时,则能访问所有的内存空间和对象,且所占有的处理器是不允许被抢占的

- 通常来说,以下三种情况会导致用户态到内核态的切换

  系统调用,异常,中断

## 进程间通信方法

​		每个进程各自有不同的用户地址空间,任何一个进程的全局变量在另一个进程中都看不到,所以进程之间要交换数据必须通过内核,在内核中开辟一块缓冲区,进程A把数据从用户空间拷到内核缓冲区,进程B再从内核缓冲区把数据读走,内核提供的这种机制称为进程间通信

- 匿名管道(pipe):管道是一种半双工的通信方式,数据只能单向流动,而且只能在具有亲缘关系的进程间使用,进程的亲缘关系通常是指父子进程关系.

- 高级管道(popen):将另一个程序当做一个新的进程在当前程序进程中启动,则它算是当前程序的子进程,这种方式我们成为高级管道方式

- 有名管道(namedpipe):有名管道也是半双工的通信方式,但是它允许无亲缘关系进程间的通信。

- 消息队列(messagequeue):消息队列是由消息的链表,存放在内核中并由消息队列标识符标识。消息队列克服了信号传递信息少、管道只能承载无格式字节流以及缓冲区大小受限等缺点

- 信号量(semophore):信号量是一个计数器,可以用来控制多个进程对共享资源的访问。它常作为一种锁机制,防止某进程正在访问共享资源时,其他进程也访问该资源。因此,主要作为进程间以及同一进程内不同线程之间的同步手段。

- 信号(sinal)信号是一种比较复杂的通信方式,用于通知接收进程某个事件已经发生。

- 共享内存(sharedmemory)：共享内存就是映射一段能被其他进程所访问的内存,这段共享内存由一个进程创建,但多个进程都可以访问。共享内存是最快的IPC方式,它是针对其他进程间通信方式运行效率低而专门设计的。它往往与其他通信机制,如信号两,配合使用,来实现进程间的同步和通信

- 套接字(socket)：套接口也是一种进程间通信机制,与其他通信机制不同的是,它可用于不同机器间的进程通信。

# 孤儿进程,僵尸进程

- 孤儿进程：一个父进程退出,而它的一个或多个子进程还在运行,那么那些子进程将成为孤儿进程。孤儿进程将被init进程(进程号为1)所收养,并由init进程对它们完成状态收集工作

- 僵尸进程：一个进程使用fork创建子进程,如果子进程退出,而父进程并没有调用wait或waitpid获取子进程的状态信息,那么子进程的进程描述符仍然保存在系统中。这种进程称之为僵死进程

- 孤儿进程是没有父进程的进程,孤儿进程这个重任就落到了init进程身上,每当出现一个孤儿进程的时候,内核就把孤儿进程的父进程设置为init,而init进程会循环地wait()它的已经退出的子进程。这样,当一个孤儿进程凄凉地结束了其生命周期的时候,init进程就会处理它的一切善后工作。因此孤儿进程并不会有什么危害

- unix提供了一种机制可以保证只要父进程想知道子进程结束时的状态信息,就可以得到。在每个进程退出的时候,内核释放该进程所有的资源,包括打开的文件,占用的内存等。但是仍然为其保留一定的信息(包括进程号,退出状态,运行时间等)。直到父进程通过wait/waitpid来取时才释放。但这样就导致了问题,如果进程不调用wait/waitpid的话,那么保留的那段信息就不会释放,其进程号就会一直被占用,但是系统所能使用的进程号是有限的,如果大量的产生僵死进程,将因为没有可用的进程号而导致系统不能产生新的进程.此即为僵尸进程的危害,应当避免。

## 线程怎么调度

​		在资源一定的情况下,调度算法需要在吞吐量,平均响应时间(延迟),公平性,调度引起的额外开销等几个方面做权衡

- 先进先出算法（FIFO,First-In-First-Out）队列中任务的耗时差不多的场景

  按照任务进入队列的顺序,依次调用,执行完一个任务再执行下一个任务,只有当任务结束后才会发生切换。

  优点：

  - 最少的任务切换开销（因为没有在任务执行过程中发生切换,故任务切换开销为0）
  - 最大的吞吐量（因没有任务切换开销,在其他一定的情况下,吞吐量肯定是最大的）
  - 最朴实的公平性（先来先做）

  缺点：

  - 平均响应时间高：耗时只需10毫秒的任务若恰巧在耗时1000毫秒的任务后到来,他则需要1010毫秒才能执行完成,绝大部分时间都花在等待被调度了。

- 最短耗时任务优先算法（ShortestJobFirst,SJF）几乎不用

  优点：

  - 平均响应时间较低：这里有一点,因为将时间长的任务无限往后推移,实际计算的平均响应时间的任务都是执行较快的任务,统计出来的平均响应时间必然较低的。

  缺点：

  - 耗时长的任务迟迟得不到调度,不公平,容易形成饥饿
  - 频繁的任务切换,调度的额外开销大

- 时间片轮转算法（RoundRobin）

  给队列中的每个任务一个时间片,第一个任务先执行,时间片到了之后,将此任务放到队列尾部,切换到下个任务执行,这样能解决SJF中耗时长任务饥饿的问题。算法介于FIFO和SJF之间,若时间片足够大,则退化到FIFO,若分片足够小（假设不考虑任务切换的开销）,则任务的完成时间顺序是以耗时从小到大排列（相比SFJ,任务执行的绝对时间会长,取决于队列中任务的个数

  优点：

  - 每个任务都能够得到公平的调度
  - 耗时短的任务即使落在耗时长的任务后面,也能够较快的得到调度执行

  缺点：

  - 任务切换引起的调度开销较大,需要多次切换任务上下文（特别是CPU的Cache,多次切换容易导致Cache完全不命中,需要重新从内存加载,这个非常耗时）
  - 时间片不太好设置（若设置短了,调度开销大,若设置长了,极端情况是退化到FIFO）

- Multi-levelFeedbackQueue（MFQ）

## IO多路复用epoll和select区别

# 计算机网络

## OSI和TCP/IP

| OSI七层网络模型      | TCP/IP模型 | 对应协议                           |
| -------------------- | ---------- | ---------------------------------- |
| 应用层(Application)  | 应用层     | HTTP,TFTP,FTP,NFS,SMTP,WAIS        |
| 表示层(Presentation) |            | Telnet,Rlogin,SNMP,Gopher          |
| 会话层(Session)      |            | SMTP,DNS                           |
| 传输层(Transport)    | 传输层     | TCP,UDP                            |
| 网络层(Network)      | 网络层     | IP,ICMP,ARP,RARP,AKP,UUCP          |
| 数据链路层(DataLink) | 数据链路层 | FDDI,Ethernet,Arpanet,PDN,SLIP,PPP |
| 物理层(Physical)     |            | IEEE802.1A,IEEE808.2到IEEE802.11   |

物理层:传输比特流0和1

数据链路层:根据以太网协议将一组电信号组成一个数据包,称作"帧",帧分为两部分,标头和数据,其中标头标明数据发送者,接收者,数据类型

网络层:IP寻址和路由选择,建立主机与主机之间的连接

传输层:建立端口到端口的连接

会话层:

表示层:

应用层:

## TCP和UDP的区别

1. TCP面向连接,UDP面向非连接
2. TCP具有可靠性
3. TCP具有有序性
4. UDP传输速度快
5. TCP重量级,TCP头20字节,UDP8字节

## TCP三次握手,四次挥手

- 握手
  - 第一次握手：建立连接时,客户端发送SYN包到服务器,之后客户端进入SYN_SEND状态,等待服务端确认
  - 第二次握手：服务端收到客户端发送的SYN包,必须确认客户端的SYN包,同时自己也向客户端发送SYN包,即服务端发送SYN+ACK包,发送之后服务端进入SYN_RECV状态
  - 第三次握手：客户端收到服务器的SYN+ACK包之后,向服务端发送确认包,此包发送完毕后,客户端服务端都进入ESTAB_LISHED状态,此时客户端服务端可以进行传输数据,完成三次握手

- 挥手
  - 第一次挥手：Client向Server发送一个FIN包,关闭Client到Server的数据传输,发送后Client进入FIN_WAIT_1状态
  - 第二次挥手：Server收到Client的FIN包,发送一个ACK确认给Clinet,Server进入CLOSE_WAIT状态
  - 第三次挥手：Server向Client发送FIN包,关闭Server到Client的数据传输,发送后Server进入LAST_ACK状态
  - 第四次挥手：Client收到FIN包后,Client进入TIME_WAIT状态,接着发送一个ACK给Server,Server收到ACK之后直接进入CLOSED状态,Client需要等待2MSL之后进入CLOSED状态

## TCP握手存在的隐患

​	TCP在首次握手存在的隐患为：**SYN超时**

​	Server收到Client的SYN包之后，回复SYN-ACK之后确一直收不到Client的ACK确认，即没有完成三次握手

​	发生上述情况后，Server会不断重试，Linux默认重试5次等待63秒后断开TCP连接

​	这种情况可能造成**SYN-Flood攻击**，SYN-Flood攻击是一种典型的**Dos**（拒绝服务攻击），恶意程序持续向Server发送SYN包却不响应ACK，直到把SYN队列耗尽

解决方案：SYN队列被耗尽之后，通过tcp-syncookies参数发送SYN Cookie，若为正常连接的Client会发送SYN Cookie，建立连接

## TCP需要四次挥手才能断开连接

因为TCP是**全双工**，发送方和接收方都需要发送FIN报文和ACK报文

## TCP如何保证可靠性(确认重传)

TCP 接收方缓存内有三种状态

- 已接收并且发送了ACK确认状态
- 未接收，但是可以接收状态（称为接收窗口）
- 未接收状态

TCP传输的可靠性来自**确认重传**，TCP滑动窗口的可靠性也来自确认重传

发送发之后收到接收方对于本段发送窗口内字节的ACK确认后才会移动发送窗口的左边界，接收窗口只有在前面所有段都确认的情况下才会移动左边界（当接收窗口中前面还有字节未接收，就收到了后面的字节，接收窗口的左边界是不会移动的，并不会对后面的字节进行确认，确保前面的数据会进行重传）

## TCP拥塞控制（快速恢复、快速重传）

## TCP十六位校验和怎么实现的

## TCP粘包

## UDP实现可靠连接

## time-wait的作用

## http和https区别

## https详细过程,握手,为什么需要非对称加密和对称加密

## http2.0了解吗？和http1.1的差距？

## getposthead区别。还有什么其他方法。分别说说是做什么的。

## http401403

## HTTP keep-alive作用

## http能不能一次连接多次请求,不等后端返回

# Linux命令

## grep命令查找日志

## linux命令,查看端口占用,cpu负载,内存占用,如何发送信号给一个进程

# MYSQL

mysql底层有哪几种实现方式

数据库如何建索引

b树b+树区别

mysql索引为什么要用B+树？为什么不使用Hash结构

事务隔离级别

事务是怎么实现的?(undo_log,MVCC)

# 分布式

什么是分布式系统

分布式系统引出负载均衡

负载均衡算法有哪些

一致性哈希算法深挖。一致性哈希与普通哈希的区别。

# 常见算法题

基本排序,哪些是稳定的

算法题：三数之和

算法题遍历二叉树

循环有序数组找指定值,

数据结构：常用排序算法,快排、堆排的原理和实现。

算法：topK,时间复杂度

raft算法是那种一致性算法,raft有什么特点

# REDIS

分布式缓存框架,singleflight并发,深挖,一直挖sync.WaitGroup

缓存击穿缓存雪崩

Redis怎么保证数据一致性

跳表的实现?

Redis其他的数据结构(SDS,RAW,INTSET,ZIPLIST,SKIPLIST,QUICKLIST)

# GOLANG

请你说说golang的CSP思想

Go闭包

gochannelclose后读问题

channel底层实现

javanio和go区别

goslice和array区别

slice,len,cap,共享,扩容

for循环遍历slice有什么问题

map取一个key,然后修改这个值,原map数据的值会不会变化

实现set

map如何顺序读取？

Golang调度器GMP模型

sync.WaitGroup

gostruct能不能比较？

godefer（fordefer）

select可以用于什么？

context包的用途？

读写锁底层是怎么实现的？

go实现消息队列（多生产者,多消费者）

go-micro服务发现

服务发现有哪些机制

go-micro微服务架构怎么实现水平部署的,代码怎么实现？

当go服务部署到线上了,发现有内存泄露,该怎么处理

go内存逃逸分析了栈帧,讲五种例子,描述堆栈优缺点,

# WEB安全

# DOCKER

# K8S

# Cookie和Session

cookiesession是什么

session如何存储

多台服务器session存储怎么设计。除了存redis还能怎么存什么



# 手写代码

手撕代码LRU

手撕代码生产者消费者模型

手撕代码反转连表



# GIT

git文件版本,使用顺序,merge跟rebase



设计学生成绩数据库,并写出查询语文成绩top3的人。url输入全过程。从此引出后端除了响应请求还有什么。

设计一个短链接服务。如何抗住大qps,抗大流量。url哈希函数怎么设计（怎么存,怎么统计qps）



反爬了解吗？反爬的几项技术在项目里面怎么实现的？

爬虫如何做的鉴权吗？

怎么实现的分布式爬虫



项目部署的服务器是单机的,请问如果是大流量高并发请求服务器怎么处理？

如果是亿级数据怎么处理？

大文件排序

死锁条件,如何避免

电商系统图片多会造成带宽过高,如何解决？

CI/CD发布流程